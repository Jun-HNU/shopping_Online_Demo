1.深度优先搜索--先序遍历的原理
2.广度优先搜索--（层次遍历）求最大最小深度
3.二叉树的空间复杂度和时间复杂度。
4.前中后序遍历。

前序遍历：根节点，左子树，右子树
中序遍历：左子树，根节点，右子树
从前序数组中找到子树的根节点，也就是前序数组的第一个元素。
根据根节点的值找到中序根节点在中序数组中的位置（事先将数组值和索引存入hashMap，方便查询），根节点的左侧为左子树的区间，右侧为右子树的区间。

而子树的中序数组的长度和前序数组的长度是一样。
base case是由根节点 的值构建根节点，再迭代填充节点的左子树和右子树。

5.二叉搜索树（Binary Search Tree，后文简写 BST）相关的文章，手把手带你刷 BST。

首先，BST 的特性大家应该都很熟悉了：

1、对于 BST 的每一个节点node，左子树节点的值都比node的值要小，右子树节点的值都比node的值大。

2、对于 BST 的每一个节点node，它的左侧子树和右侧子树都是 BST。

二叉搜索树并不算复杂，但我觉得它构建起了数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）。


完全二叉树：除了最后一层，其他层的节点都是满的，最后一层靠左排列。
堆或者数的好出，维护了节点之间的父子关系。

堆：元素存放在数组，第一个元素空出来，是一颗逻辑上的树，
总是从堆顶取出元素后，将最后一个元素放堆顶下沉，从堆底靠左放入元素并上浮。